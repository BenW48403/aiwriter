1.项目概述：
1.1.我们正在开发一个本地部署的应用，该应用支持作家在写作过程中通过结构化的方式来记录和组织信息。用户可以在应用的前端界面上进行操作，通过在不同区域（A区，B区，C区）中创建、编辑和删除标签，并在C区的文本编辑区中记录信息。所有这些信息都会保存在本地目录/aiwb/database/里的TXT文件中。

2.服务端功能：
2.1.项目运行时，自动连接到OPENAI接口，可以发送前端请求到chatGPT服务器并接受起响应结果。服务端框架：选择Django作为服务端框架。对于各个按钮的监听和后台逻辑代码编写，将根据您的需求进行开发。

3.前端页面设计：
3.1.前端页面包括A区，B区，C区和D区。A区和B区是标签区，C区是文本编辑区，D区是与ChatGPT的聊天对话框。标签包括一级、二级和三级标签，它们之间有从属关系。所有标签和文本内容都需要保存到数据库中。

4.标签设计：
4.1.A区是一级标签，B区包含二级标签和三级标签。二级标签包含自定义标签和固定标签，固定标签包含三级标签。三级标签附属于固定标签，二级标签附属于对应的一级标签。

5.用户交互逻辑：
5.1.用户可以在A区创建新书（一级标签），在B区创建书本设定（二级自定义标签），然后在相应的C区记录具体内容。然后用户在B区目录（二级固定标签）规划（二级固定标签里的数字输入框）新书的章节（三级标签）。用户一边在D区和ChatGPT商讨，一边在具体章节（三级标签）对应的C区写下内容。点击三级标签，C区显示对应的文本编辑区和顶部分页栏。

6.前端布局和交互规则：
6.1.四个区域的布局：从左到右，左边留白16个像素，A区和B区各占220个像素，C区880个像素，D区550个像素。从上到下，上边留白72个像素，A区、B区、C区、D区高度皆为720个像素。四个区域左右相连，皆有黑色边框。A区、B区、C区、D区为固定区域，浏览里面内容提供上下滚动功能，当里面内容超过固定区域，则该区域右侧会出现垂直滚动条。

6.2.增加标签的功能：A区和B区的添加功能是一个按钮，按钮标注这一个”+“号，大小是高32个像素，宽为A区的宽度为220个像素。同时这个”+“号按钮符合以下的规则：

6.2.1.规则一、保持A区的“+”号按钮位于所有一级标签按钮的最下方。点击一下“+”号按钮，则在它上方增加一个一级标签。例如：A区从上到下原有一个一级标注1，一个“+”号按钮。点击一下“+”号按钮，A区从上到下是一级标签1，一级标签2，“+”号按钮。

6.2.2.规则二：保持B区对应一个“+”号按钮位于所有二级自定义标签按钮的最下方，固定标签的上方。另一个“+”号按钮位于所有三级标签按钮的最下方。

6.2.3.规则三：点击一下B区固定标签上方的“+”号按钮，则在它上方增加一个二级自定义标签。点击一下B区固定标签下方的“+”号按钮，则在它上方增加一个三级标签。例如：B区从上到下原有一个二级自定义标注1，一个“+”号按钮，固定标签，一个三级标签1，一个“+”号按钮。点击一下固定标签上方的“+”号按钮，则B区从上到下一个二级自定义标注1，一个二级自定义标注2，一个“+”号按钮，固定标签，一个三级标签，一个“+”号按钮。这时再点击一下固定标签下方的“+”号按钮，则B区从上到下一个二级自定义标注1，一个二级自定义标注2，一个“+”号按钮，固定标签，一个三级标签1，一个三级标签2，一个“+”号按钮。

6.3.A区和B区的三个“+”号按钮的大小相同，高32个像素，宽为A区的宽度为220个像素。按钮有黑线边框。

6.4.一、二、三级标签标签的定义：高度为32个像素，宽为A区的宽度为220个像素。有黑线边框。标签与标签，标签与“+”号按钮上下相连。

6.5.一级标签的分布：一级标签在A区“+”号按钮上方，即点击“+”号按钮，会在它上方创建新标签。当用户创建一级标签时，后端应该在本地目录/aiwb/database/里生成相应的TXT文件，TXT的命名应与一级标签的命名相同。

6.6.二、三级标签的分布：当一级标签被创建，对应的B区默认会出现从上到下的是：“+”号按钮，固定标签（标注为”目录：共“输入框”章节“），“+”号按钮。点击固定标签上方的“+”号按钮，会在该“+”号按钮上方增加二级自定义标签。点击固定标签下方的“+”号按钮，会在该“+”号按钮上方增加三级标签。

6.7.固定标签的定义：固定标签上标注为”目录：共“输入框”章节“。标注的文字不能被编辑，输入框里可以填数字。有黑线边框。

6.8.B区固定标签的输入框定义：数字1到10000是下划线上有效数值的输入范围。下划线上的数值永远等于所有三级标签数量。

6.8.1.规则四：当在固定标签里的输入框里输入有效数值，则在固定标签下方自动生成相应数量的三级标签。

6.8.2.规则五：在固定标签里的输入框里输入有效数值时，有效数值应大于等于已经存在的三级标签总数，否则提示输入无效。如果大于已经存在的三级标签总数则在最后一个已有三级标签下补全不足数量的三级标签。如果等于已经存在的三级标签总数，则三级标签数量不变。

6.8.3.规则六：输入框里的数字永远等于三级标签的数量。当点击三级标签下方的“+”号按钮，增加了一个三级标签，则输入框里的数值加1。

6.9.一级标签、二级自定义标签名字定义：一级标签默认标注为"Book1”"Book2”"Book3”～～；二级自定义标签默认标注为“新标签1”“新标签2”“新标签3”～～，双击文字可直接在标签上修改名称。当用户给一个已经创建好的标签改名时选择了与已有标签相同的名字时，应该拒绝本次重命名并提醒用户重名。

6.10.三级标签名字定义：三级标签默认标注为“第1章”“第2章”“第3章”～～中间数字按所有三级标签排序，双击文字可直接在标签上修改名称。当用户给一个已经创建好的标签改名时选择了与已有标签相同的名字时，应该拒绝本次重命名并提醒用户重名。

6.11.C区布局一：当点击B区自定义标签时，C区顶部没有分页栏，全是文本编辑区。即C区就是文本编辑区。

6.12.C区布局二：当点击B区三级标签时，C区顶部有分页栏，分页栏从左到右有6个选项卡，分页栏以外即为文本编辑区。每个选项卡各自对应一个文本编辑区。

6.13.C区分页栏设定：每个三级标签对应C区都有6个选项卡（选项卡位于C区顶部的分页栏），从左到右分别标注为characters，background，structure，Conflict，theme，text。6个选项卡高度等于分页栏高度，分页栏高度为24个像素。6个选项卡平分分页栏宽度，分页栏宽度等于C区宽度。双击选项卡里文字可直接在选项卡上修改名称。

6.14.C区没有聊天功能，都是用户的文本编辑区输入。

6.15.D区布局：D区底部往上20个像素，从左到右30个像素有文字输入框和“发送”按钮。文字输入框高32个像素，宽460个像素。“发送”按钮高32个像素，宽30个像素。两者都有黑色边框。

6.16.D区文字输入框：文字输入框是一个可自动调整高度的输入区域，它会根据用户输入的文字内容动态调整高度，以适应超过一行的文本。其特点包括：

6.16.1.自动调整高度：当用户输入的文字超过一行时，文字输入框会自动调整高度，以容纳全部文本内容。这样，用户可以轻松查看和编辑超过一行的文本。

6.16.2.垂直滚动条：如果用户输入的文字超过输入框可见区域的高度，会出现垂直滚动条，以便用户可以滚动查看和编辑超出可见区域的文本。

6.16.3.适应内容变化：当用户输入的文本内容减少，文字输入框会相应地减小高度，以适应新的文本大小。

6.17.D区的聊天区：文字输入框以上，左右还有上方各留30个像素留白，其它就是聊天区：

6.17.1.消息展示：每一条消息通常由两个主要部分组成：发送者和消息内容。

6.17.2.发送者：在每条消息前面，显示发送者的名称。用户是“user”、chatgpt是“gpt”。

6.17.3.消息内容：在发送者标识后面，显示实际的消息内容。

6.17.4.对齐方式：消息以对齐方式显示，以区分发送者和接收者的消息。例如，发送者的消息可能靠右对齐，而接收者的消息靠左对齐。

6.17.5.消息气泡：每条消息包含一个气泡或背景，用于突出显示消息的边界。气泡是圆角矩形。

6.17.6.滚动功能：提供上下滚动功能来浏览历史消息。当里面内容超过固定区域，则该区域右侧会出现垂直滚动条。

6.17.7.字体与大小：A区、B区、C区、D区的字体都采用宋体，大小16个像素

6.18.关于颜色和主题的设定：

6.18.1. 当标签没有被选定时，颜色为白色；当标签被选定，颜色为#FAD278。

6.18.2.对于A区和B区，标签以外的空白处为白色。

6.18.3.对于C区，被选定的分页按钮颜色为#16878C，未被选定的分页按钮颜色为白色。文本编辑区的底色为#FAD278。

6.18.4.  进一步举例说明：

6.18.4.1.  假设A区有三个一级标签分别为a、b、c，现选定a

6.18.4.2.假设B区对应A区的a有三个自定义标签分别为a1、a2、a3，固定标签为a4，a4下面有5个三级标签分别为a4001、a4002、a4003，a4004、a4005，现选定的是a4003  则：a，a4，a4003的颜色皆为#FAD278，其它的所有标签为白色。

6.18.5.  假设我们现在只选中a，则B区所有二、三级标签都为白色。

6.18.6.  假设我们现在选中了a和a4，则B区除了a4以外其它标签都为白色。

7.数据库设计：
7.1.从本地目录/aiwb/database/中并加载数据库。前端页面发送所有一，二，三级标签及C区内容，根据前端页面请求展示出对应的内容。一个一级标签对应一个TXT文件，内容存储以TXT文件存放在本地目录/aiwb/database/中。当用户创建一级标签时，后端应该在本地目录/aiwb/database/里生成相应的TXT文件，TXT的命名应与一级标签的命名相同。


7.2.需要一个解析器，用于解析TXT文件，提取出标签和内容。解析器需要能够处理不同级别的标签，例如一级标签（书名）、二级标签（自定义标签）和三级标签（章节）。解析器也需要能够处理C区的6个选项卡的内容。

7.3.解析器需要能够处理用户对标签名称的修改。例如，如果用户双击一个标签，输入一个新的名称，解析器需要能够识别这个新的名称，并在TXT文件中更新这个标签的名称。

7.4.解析器需要能够处理用户对C区内容的修改。例如，如果用户在C区的一个选项卡中输入了新的内容，解析器需要能够识别这个新的内容，并在TXT文件中更新这个选项卡的内容。

7.5.解析器需要能够处理用户对章节数量的修改。例如，如果用户在B区输入了一个新的章节数量，解析器需要能够识别这个新的数量，并在TXT文件中更新章节的数量。

7.6.解析器需要能够处理用户对应用的关闭和重新打开。例如，如果用户关闭了应用，然后重新打开，解析器需要能够从TXT文件中提取出所有的标签和内容，并在应用中恢复这些信息。

7.7.解析器需要能够处理用户对TXT文件的导入和导出。例如，如果用户导入了一个新的TXT文件，解析器需要能够从这个文件中提取出所有的标签和内容，并在应用中显示这些信息。如果用户导出了TXT文件，解析器需要能够将应用中的所有标签和内容保存到这个文件中。

7.8.每本书对应一个TXT文件，所以一个TXT文件只包含一个一级标签。TXT的命名应与一级标签的命名相同，并存放在本地目录/aiwb/database/文件夹中

7.9.二级自定义标签只对应它的C区文本，二级自定义标签与三级标签无关。

7.10.TXT文件将存储在本地电脑上。

7.11.TXT文件存储内容与聊天消息无关。

7.12.TXT文件的格式可以设计如下：
# 开始:TXT文件的格式设计
# Book: Book1
## Custom Tag: Tag1
This is the content for the custom tag.
### Chapter: Chapter1
#### characters
This is the content for the characters tab.
#### background
This is the content for the background tab.
#### structure
This is the content for the structure tab.
#### Conflict
This is the content for the Conflict tab.
#### theme
This is the content for the theme tab.
#### text
This is the content for the text tab.
## Custom Tag: Tag2
This is the content for the custom tag.
### Chapter: Chapter2
#### characters
This is the content for the characters tab.
#### background
This is the content for the background tab.
#### structure
This is the content for the structure tab.
#### Conflict
This is the content for the Conflict tab.
#### theme
This is the content for the theme tab.
#### text
This is the content for the text tab.
#结束：TXT文件的格式设计

8.前后端交互逻辑：
8.1.当项目启动时，后端应该读取/aiwb/database/目录下的所有TXT文件，解析出所有一级标签，并将这些标签发送到前端。前端在A区显示这些一级标签。

8.2.当用户在A区点击一个一级标签时，后端应该读取该一级标签对应的TXT文件，解析出所有的二级自定义标签和三级标签，以及这些标签对应的C区文本编辑区的内容。然后，后端将这些标签和内容发送到前端。前端在B区显示这些标签，并在C区显示对应的内容。

8.3.用户没有保存之前，只要是在同一个一级标签下的所有操作都应该暂存在内存里。包括创建、删除或重命名二、三级标签，以及对二、三级标签对应的C区一切的文件操作。

8.4.当用户在B区创建或修改二、三级标签时，前端应该更新其内存中的数据结构，以反映这些更改。同样，当用户在C区编辑文本时，前端也应该更新其内存中的数据结构。

8.5.当用户在B区切换二、三级标签时，前端应该从其内存中的数据结构中获取对应的C区内容，并在C区显示这些内容。

8.6.当用户在C区切换选项卡时，前端应该从其内存中的数据结构中获取对应的文本，并在文本编辑区显示这些文本。

8.7.当用户点击保存按钮时，前端应该将其内存中的数据结构转换为TXT文件的格式，并将这些数据发送到后端。后端接收这些数据，并将其保存到对应的TXT文件中。

8.8.当用户切换一级标签时，前端应该弹出提示窗口，询问用户是否要保存更改。如果用户选择保存，则执行步骤6。如果用户选择不保存，则丢弃当前的更改，并执行步骤2，加载新的一级标签的数据。

8.9.当用户创建新的一级标签时，后端应该在/aiwb/database/目录下创建一个新的TXT文件。这个TXT文件的名称应该与一级标签的名称相同。当用户重命名一级标签时，TXT文件的名称也要跟着改变，保持与一级标签一致。

8.10.“导出”按钮：
8.10.1.用户点击“导出”按钮。
8.10.2.弹出提示框提示是否确认需要导出当前的一级标签。
8.10.3.用户确认导出。
8.10.4.使用 Fetch API 发送一个 HTTP 请求到后端，请求中包含当前一级标签。
8.10.5.后端接收到前端的请求，这个请求包含了当前一级标签和所有相关的更新。
8.10.6.后端找到与当前一级标签对应的TXT文件。
8.10.7.后端使用Markdown解析器将前端的更新转换为Markdown格式。
8.10.8.后端将转换后的Markdown内容写入到TXT文件中，覆盖原有的内容。
8.10.9.后端将更新后的TXT文件发送回前端。
8.10.10.前端处理后端返回的 TXT 文件，例如下载这个文件。

8.11.“导入”按钮：
8.11.1.用户点击“导入”按钮。
8.11.2.弹出提示框，浏览本地目录和文件，提示选择需要导入的 TXT 文件。
8.11.3.用户选中 TXT 文件。
8.11.4.使用 File API 来读取这个文件的内容，然后将这个内容打包成一个 HTTP 请求发送到后端。
8.11.5.后端接收到这个请求后，使用 Markdown 解析器来解析这个文件，并将解析结果保存到数据库。
8.11.6.后端将生成的标签发送回前端，前端接收到这些标签后，在 A 区所有一级标签之后，"+"号按钮之前添加一个新的一级标签，并重命名· 与被导入的 TXT 文件的名称一致。

8.12.“保存”按钮：
8.12.1.用户点击“保存”按钮。
8.12.2.弹出提示框提示是否需要保存当前的一级标签。
8.12.3.用户确认保存。
8.12.4.使用 Fetch API 发送一个 HTTP 请求到后端，请求中包含当前一级标签。
8.12.5.后端接收到这个请求后，使用 Markdown 解析器来生成对应的内容，然后将这些内容写入，覆盖并保存在与一级标签对应的 TXT 文件上。

8.13.“删除”按钮：
8.13.1.用户点击“删除”按钮。
8.13.2.弹出提示框提示用户是否需要删除当前的标签并显示当前标签的名称。
8.13.3.如果当前 B 区有被选定的标签，则该被选定的标签被默认为准备删除的标签；如果当前用户没有选择 B 区里任何标签，用户只选择了一级标签，则该被选定的一级标签将会被默认为准备删除的标签。
8.13.4.用户点击确认。
8.13.5.使用 Fetch API 发送一个 HTTP 请求到后端，请求中包含用户选择的标签。
8.13.6.后端接收到这个请求后，会从对应的 TXT 文件中删除这个标签。

8.14.补充说明：关于用户权限管理。没有用户权限限制，任何用户都可以进行信息的修改、增加、删除等操作。关于测试和部署。按照通常的软件开发流程进行开发、测试和部署，无需特殊要求。

9.当前项目的目录结构：
/aiwb
  /database
  manage.py
  /aiwb
    _init_.py
    asgi.py
    settings.py
    urls.py
wsgi.py
markdown_parser.py
    error_handler.py
  /myapp
    _init_.py
    admin.py
    apps.py
    models.py
    tests.py
    urls.py
    views.py
    /migrations
      _init_.py
    /templates
     /myapp
      index.html
    /static
     /myapp
      main.js
      styles.css